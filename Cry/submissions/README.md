请在这里提交第一周作业
#sage
![d47febc13722c21a8405c3ea3437f3ad](https://github.com/user-attachments/assets/24436e21-d180-495b-b1d3-301939778aaa)
#作业1
import gmpy2
#导入用于高精度数学运算的库
from Crypto.Util.number import long_to_bytes
#将最大整数转换为字节（用于将解密后的明文从数字转换为可读字符串）

p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
#两个大质数
e = 65537
#公钥
c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034
#密文
n = p * q
#计算模
phi = (p - 1) * (q - 1)
#计算欧拉函数
d = int(gmpy2.invert(e, phi))
#计算私钥d(e对于phi的模反元素）
m = int(gmpy2.powmod(c, d, n))
#解密计算明文

print("m =", m)
print("flag =", long_to_bytes(m).decode('latin-1'))
#输出明文数字和转换为字符串的flag
m = 5577446633554466577768879988
flag = CÙàÂ%YÁt 不知道为啥flag是乱码，求学长指教
#作业2
import gmpy2
#导入用于高精度数学运算的库
from Crypto.Util.number import long_to_bytes
#将最大整数转换为字节（用于将解密后的明文从数字转换为可读字符串）
# ===== 题目给出的数据 =====
p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229
q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469
#两个大质数
dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929
dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041
#私钥指数d分别对p-1和q-1取模的结果
c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852
# ======================
n = p * q
#计算模
qInv = gmpy2.invert(q, p)
#求 q 在模 p 下的乘法逆元
#再往下的内容就不会了，是用ai才勉强做出来的
mp = pow(c, dp, p)
mq = pow(c, dq, q)
#分别模幂解密
m = (mq + q * ((qInv * (mp - mq)) % p)) % n
#CRT 合并公式（Garner 算法）
#把两个碎片  mp、mq  拼成真正的  m mod n
flag = long_to_bytes(m).decode(errors='ignore')
#把大整数 m 转成字节数组，并将直接转为可读字符串
print("明文：", flag)
#输出明文flag
#明文： noxCTF{W31c0m3_70_Ch1n470wn}
作业三
import gmpy2
import libnum
c = 175676150266622974236396526711286850987631123485212632328509227849029911058091086706143340012942548868507757097027596460222082381606490997654543157611859508598203272345044220266344322516323997126214392011463091635444512796333373451321795475333496092463760390199602320265733668648810943598505902205569125
n = 1101676297168703265566511587913652821222614528632844563918598090813090976948138058144049294690727841463413972173051671908835164088465174349647584948964206244648736138253802417241570633968307801570794459668533128958442296813160786428069813867034205462528763830205245218089660432399549540588101288362866463
e = 3
# 立方根直接开
m, exact = gmpy2.iroot(c, e)
if exact:
    flag = libnum.n2s(int(m)).decode()
    print("明文：", flag)
else:
    print("不是纯立方，需别的攻击")





















